//! Code generation routes

use axum::{
    extract::State,
    Json,
};
use serde::Serialize;

use crate::{AppState, ApiError};

/// Generated code response
#[derive(Debug, Serialize)]
pub struct GeneratedCode {
    pub files: Vec<GeneratedFile>,
}

#[derive(Debug, Serialize)]
pub struct GeneratedFile {
    pub path: String,
    pub content: String,
}

/// Generate frontend code (React)
pub async fn generate_frontend(
    State(state): State<AppState>,
) -> Result<Json<GeneratedCode>, ApiError> {
    let project = state.get_project().await
        .ok_or_else(|| ApiError::NotFound("No project loaded".into()))?;
    
    // Generate React App.tsx
    let app_content = format!(r#"// Generated by Grapes IDE
import React from 'react';
import {{ BrowserRouter as Router, Routes, Route }} from 'react-router-dom';

// Pages
{}

function App() {{
  return (
    <Router>
      <Routes>
{}
      </Routes>
    </Router>
  );
}}

export default App;
"#,
        project.pages.iter()
            .filter(|p| !p.archived)
            .map(|p| format!("import {} from './pages/{}';\n", pascal_case(&p.name), p.name))
            .collect::<String>(),
        project.pages.iter()
            .filter(|p| !p.archived)
            .map(|p| format!("        <Route path=\"{}\" element={{<{} />}} />\n", p.path, pascal_case(&p.name)))
            .collect::<String>()
    );
    
    let package_json = serde_json::json!({
        "name": project.name.to_lowercase().replace(" ", "-"),
        "version": "1.0.0",
        "private": true,
        "dependencies": {
            "react": "^18.2.0",
            "react-dom": "^18.2.0",
            "react-router-dom": "^6.20.0"
        },
        "scripts": {
            "start": "vite",
            "build": "vite build"
        },
        "devDependencies": {
            "vite": "^5.0.0",
            "@vitejs/plugin-react": "^4.2.0"
        }
    });
    
    Ok(Json(GeneratedCode {
        files: vec![
            GeneratedFile {
                path: "src/App.tsx".into(),
                content: app_content,
            },
            GeneratedFile {
                path: "package.json".into(),
                content: serde_json::to_string_pretty(&package_json).unwrap(),
            },
        ],
    }))
}

/// Generate backend code (NestJS)
pub async fn generate_backend(
    State(state): State<AppState>,
) -> Result<Json<GeneratedCode>, ApiError> {
    let project = state.get_project().await
        .ok_or_else(|| ApiError::NotFound("No project loaded".into()))?;
    
    // Generate main.ts
    let main_content = r#"// Generated by Grapes IDE
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.enableCors();
  await app.listen(3000);
}
bootstrap();
"#;
    
    // Generate controllers
    let mut files = vec![
        GeneratedFile {
            path: "src/main.ts".into(),
            content: main_content.into(),
        },
    ];
    
    // Generate controller for each API
    for api in project.apis.iter().filter(|a| !a.archived) {
        let controller_content = format!(r#"// Generated by Grapes IDE
import {{ Controller, {method} }} from '@nestjs/common';

@Controller('{base_path}')
export class {name}Controller {{
  @{method}()
  async handle{name}() {{
    return {{ success: true, message: '{name} handled', path: '{base_path}' }};
  }}
}}
"#,
            method = format!("{:?}", api.method),
            base_path = api.path.trim_start_matches('/'),
            name = pascal_case(&api.name),
        );
        
        files.push(GeneratedFile {
            path: format!("src/controllers/{}.controller.ts", api.name.to_lowercase().replace(" ", "-")),
            content: controller_content,
        });
    }
    
    Ok(Json(GeneratedCode { files }))
}

/// Generate database schema (Prisma)
pub async fn generate_database(
    State(state): State<AppState>,
) -> Result<Json<GeneratedCode>, ApiError> {
    let project = state.get_project().await
        .ok_or_else(|| ApiError::NotFound("No project loaded".into()))?;
    
    let mut schema = String::from("// Generated by Grapes IDE\n\n");
    schema.push_str("datasource db {\n  provider = \"sqlite\"\n  url      = \"env(\"DATABASE_URL\")\"\n}\n\n");
    schema.push_str("generator client {\n  provider = \"prisma-client-js\"\n}\n\n");
    
    for model in project.data_models.iter().filter(|m| !m.archived) {
        schema.push_str(&format!("model {} {{\n", model.name));
        
        for field in &model.fields {
            let prisma_type = match field.field_type {
                crate::schema::data_model::FieldType::String => "String",
                crate::schema::data_model::FieldType::Int => "Int",
                crate::schema::data_model::FieldType::Float => "Float",
                crate::schema::data_model::FieldType::Boolean => "Boolean",
                crate::schema::data_model::FieldType::DateTime => "DateTime",
                crate::schema::data_model::FieldType::Json => "Json",
                crate::schema::data_model::FieldType::Uuid => "String",
                crate::schema::data_model::FieldType::Email => "String",
                crate::schema::data_model::FieldType::Url => "String",
                crate::schema::data_model::FieldType::Bytes => "Bytes",
                crate::schema::data_model::FieldType::Text => "String",
            };
            
            let mut line = format!("  {} {}", field.name, prisma_type);
            if !field.required { line.push('?'); }
            if field.primary_key { line.push_str(" @id"); }
            if field.unique { line.push_str(" @unique"); }
            
            if let Some(default) = &field.default_value {
                match default {
                    crate::schema::data_model::DefaultValue::Uuid => line.push_str(" @default(uuid())"),
                    crate::schema::data_model::DefaultValue::Now => line.push_str(" @default(now())"),
                    crate::schema::data_model::DefaultValue::AutoIncrement => line.push_str(" @default(autoincrement())"),
                    crate::schema::data_model::DefaultValue::Static { value } => line.push_str(&format!(" @default({})", value)),
                    _ => {}
                }
            }
            
            schema.push_str(&format!("{}\n", line));
        }
        
        if model.timestamps {
            schema.push_str("  createdAt DateTime @default(now())\n");
            schema.push_str("  updatedAt DateTime @updatedAt\n");
        }
        
        schema.push_str("}\n\n");
    }
    
    Ok(Json(GeneratedCode {
        files: vec![
            GeneratedFile {
                path: "prisma/schema.prisma".into(),
                content: schema,
            },
        ],
    }))
}

/// Convert string to PascalCase
fn pascal_case(s: &str) -> String {
    s.split(|c: char| !c.is_alphanumeric())
        .filter(|w| !w.is_empty())
        .map(|w| {
            let mut chars = w.chars();
            match chars.next() {
                None => String::new(),
                Some(c) => c.to_uppercase().chain(chars).collect(),
            }
        })
        .collect()
}

/// Generate ZIP archive of the entire project
pub async fn generate_zip(
    State(state): State<AppState>,
) -> Result<impl axum::response::IntoResponse, ApiError> {
    let project = state.get_project().await
        .ok_or_else(|| ApiError::NotFound("No project loaded".into()))?;

    let mut buf = Vec::new();
    let mut zip = zip::ZipWriter::new(std::io::Cursor::new(&mut buf));
    let options = zip::write::FileOptions::default()
        .compression_method(zip::CompressionMethod::Stored)
        .unix_permissions(0o755);

    // Helper to write file to zip
    let mut write_file = |path: &str, content: &str| -> Result<(), ApiError> {
        zip.start_file(path, options).map_err(|e| ApiError::Internal(e.to_string()))?;
        use std::io::Write;
        zip.write_all(content.as_bytes()).map_err(|e| ApiError::Internal(e.to_string()))?;
        Ok(())
    };

    // --- FRONTEND GENERATION ---
    
    // package.json
    let fe_package_json = serde_json::json!({
        "name": project.name.to_lowercase().replace(" ", "-"),
        "version": "1.0.0",
        "type": "module",
        "scripts": { "dev": "vite", "build": "vite build", "preview": "vite preview" },
        "dependencies": { "react": "^18.2.0", "react-dom": "^18.2.0", "react-router-dom": "^6.20.0" },
        "devDependencies": { "@types/react": "^18.2.43", "@types/react-dom": "^18.2.17", "@vitejs/plugin-react": "^4.2.1", "typescript": "^5.2.2", "vite": "^5.0.0", "tailwindcss": "^3.4.1", "postcss": "^8.4.31", "autoprefixer": "^10.4.16" }
    });
    write_file("frontend/package.json", &serde_json::to_string_pretty(&fe_package_json).unwrap())?;

    // vite.config.ts
    write_file("frontend/vite.config.ts", r#"import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
});"#)?;

    // index.html
    write_file("frontend/index.html", r#"<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Grapes App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>"#)?;

    // src/main.tsx
    write_file("frontend/src/main.tsx", r#"import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)"#)?;

    // src/index.css
    write_file("frontend/src/index.css", "@tailwind base;\n@tailwind components;\n@tailwind utilities;")?;

    // src/App.tsx
    let app_imports = project.pages.iter().filter(|p| !p.archived)
        .map(|p| format!("import {} from './pages/{}';\n", pascal_case(&p.name), p.name))
        .collect::<String>();
    
    let app_routes = project.pages.iter().filter(|p| !p.archived)
        .map(|p| format!("        <Route path=\"{}\" element={{<{} />}} />\n", p.path, pascal_case(&p.name)))
        .collect::<String>();

    write_file("frontend/src/App.tsx", &format!(r#"import {{ BrowserRouter as Router, Routes, Route }} from 'react-router-dom';
{}

function App() {{
  return (
    <Router>
      <Routes>
{}
      </Routes>
    </Router>
  );
}}
export default App;"#, app_imports, app_routes))?;

    // Pages
    for page in project.pages.iter().filter(|p| !p.archived) {
        write_file(&format!("frontend/src/pages/{}.tsx", page.name), &format!(r#"
export default function {}() {{
    return (
        <div className="p-4">
            <h1 className="text-2xl font-bold">{}</h1>
            <p>Generated page content</p>
        </div>
    );
}}"#, pascal_case(&page.name), page.name))?;
    }

    // --- BACKEND GENERATION ---

    // package.json
    let be_package_json = serde_json::json!({
        "name": format!("{}-api", project.name.to_lowercase().replace(" ", "-")),
        "version": "0.0.1",
        "scripts": { "start": "nest start" },
        "dependencies": { "@nestjs/common": "^10.0.0", "@nestjs/core": "^10.0.0", "@nestjs/platform-express": "^10.0.0", "reflect-metadata": "^0.1.13", "rxjs": "^7.8.1" },
        "devDependencies": { "@nestjs/cli": "^10.0.0", "@nestjs/schematics": "^10.0.0", "@types/express": "^4.17.17", "@types/node": "^20.3.1", "typescript": "^5.1.3" }
    });
    write_file("backend/package.json", &serde_json::to_string_pretty(&be_package_json).unwrap())?;

    // src/main.ts
    write_file("backend/src/main.ts", r#"import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.enableCors();
  await app.listen(3000);
}
bootstrap();"#)?;

    // src/app.module.ts
    let controller_imports = project.apis.iter().filter(|a| !a.archived)
        .map(|a| format!("import {{ {}Controller }} from './controllers/{}.controller';", pascal_case(&a.name), a.name.to_lowercase().replace(" ", "-")))
        .collect::<Vec<_>>().join("\n");
    
    let controller_list = project.apis.iter().filter(|a| !a.archived)
        .map(|a| format!("{}Controller", pascal_case(&a.name)))
        .collect::<Vec<_>>().join(", ");

    write_file("backend/src/app.module.ts", &format!(r#"import {{ Module }} from '@nestjs/common';
{}

@Module({{
  imports: [],
  controllers: [{}],
  providers: [],
}})
export class AppModule {{}}"#, controller_imports, controller_list))?;

    // Controllers
    for api in project.apis.iter().filter(|a| !a.archived) {
        let name = pascal_case(&api.name);
        let filename = api.name.to_lowercase().replace(" ", "-");
        write_file(&format!("backend/src/controllers/{}.controller.ts", filename), &format!(r#"import {{ Controller, {} }} from '@nestjs/common';

@Controller('{}')
export class {}Controller {{
  @{}()
  handler() {{
    return {{ message: "Hello from {}" }};
  }}
}}"#, format!("{:?}", api.method), api.path.trim_start_matches('/'), name, format!("{:?}", api.method), name))?;
    }

    // --- PRISMA SCHEMA ---
    let mut schema = String::from(r#"datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

generator client {
  provider = "prisma-client-js"
}

"#);

    for model in project.data_models.iter().filter(|m| !m.archived) {
        schema.push_str(&format!("model {} {{\n", model.name));
        for field in &model.fields {
            let prisma_type = match field.field_type {
                crate::schema::data_model::FieldType::String => "String",
                crate::schema::data_model::FieldType::Int => "Int",
                crate::schema::data_model::FieldType::Float => "Float",
                crate::schema::data_model::FieldType::Boolean => "Boolean",
                crate::schema::data_model::FieldType::DateTime => "DateTime",
                crate::schema::data_model::FieldType::Json => "Json",
                crate::schema::data_model::FieldType::Uuid => "String",
                crate::schema::data_model::FieldType::Email => "String",
                crate::schema::data_model::FieldType::Url => "String",
                crate::schema::data_model::FieldType::Bytes => "Bytes",
                crate::schema::data_model::FieldType::Text => "String",
            };
            let mut line = format!("  {} {}", field.name, prisma_type);
            if !field.required { line.push('?'); }
            if field.primary_key { line.push_str(" @id"); }
            if field.unique { line.push_str(" @unique"); }
            if let Some(default) = &field.default_value {
               match default {
                   crate::schema::data_model::DefaultValue::Uuid => line.push_str(" @default(uuid())"),
                   crate::schema::data_model::DefaultValue::Now => line.push_str(" @default(now())"),
                   crate::schema::data_model::DefaultValue::AutoIncrement => line.push_str(" @default(autoincrement())"),
                   crate::schema::data_model::DefaultValue::Static { value } => line.push_str(&format!(" @default({})", value)),
                   _ => {}
               }
            }
            schema.push_str(&format!("{}\n", line));
        }
        if model.timestamps {
            schema.push_str("  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n");
        }
        schema.push_str("}\n\n");
    }

    write_file("prisma/schema.prisma", &schema)?;

    // Drop closure to release mutable borrow of zip
    drop(write_file);

    zip.finish().map_err(|e| ApiError::Internal(e.to_string()))?;
    drop(zip);

    Ok((
        axum::http::StatusCode::OK,
        [
            (axum::http::header::CONTENT_TYPE, "application/zip"),
            (axum::http::header::CONTENT_DISPOSITION, "attachment; filename=\"project.zip\""),
        ],
        buf,
    ))
}
