//! Code generation routes

use axum::{
    extract::State,
    Json,
};
use serde::Serialize;

use crate::backend::state::AppState;
use crate::backend::error::ApiError;

/// Generated code response
#[derive(Debug, Serialize)]
pub struct GeneratedCode {
    pub files: Vec<GeneratedFile>,
}

#[derive(Debug, Serialize)]
pub struct GeneratedFile {
    pub path: String,
    pub content: String,
}

/// Generate frontend code (React)
pub async fn generate_frontend(
    State(state): State<AppState>,
) -> Result<Json<GeneratedCode>, ApiError> {
    let project = state.get_project().await
        .ok_or_else(|| ApiError::NotFound("No project loaded".into()))?;
    
    let generator = crate::generator::FrontendGenerator::new(&project);
    let output = generator.generate();
    
    Ok(Json(GeneratedCode {
        files: output.files.into_iter().map(|f| GeneratedFile {
            path: f.path,
            content: f.content,
        }).collect(),
    }))
}

/// Generate backend code (NestJS)
pub async fn generate_backend(
    State(state): State<AppState>,
) -> Result<Json<GeneratedCode>, ApiError> {
    let project = state.get_project().await
        .ok_or_else(|| ApiError::NotFound("No project loaded".into()))?;
    
    // Generate main.ts
    let main_content = r#"// Generated by Grapes IDE
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.enableCors();
  await app.listen(3000);
}
bootstrap();
"#;
    
    // Generate controllers
    let mut files = vec![
        GeneratedFile {
            path: "src/main.ts".into(),
            content: main_content.into(),
        },
    ];
    
    // Generate controller for each API
    for api in project.apis.iter().filter(|a| !a.archived) {
        let controller_content = format!(r#"// Generated by Grapes IDE
import {{ Controller, {method} }} from '@nestjs/common';

@Controller('{base_path}')
export class {name}Controller {{
  @{method}()
  async handle{name}() {{
    return {{ success: true, message: '{name} handled', path: '{base_path}' }};
  }}
}}
"#,
            method = format!("{:?}", api.method),
            base_path = api.path.trim_start_matches('/'),
            name = pascal_case(&api.name),
        );
        
        files.push(GeneratedFile {
            path: format!("src/controllers/{}.controller.ts", api.name.to_lowercase().replace(" ", "-")),
            content: controller_content,
        });
    }
    
    Ok(Json(GeneratedCode { files }))
}

/// Generate database schema (Prisma)
pub async fn generate_database(
    State(state): State<AppState>,
) -> Result<Json<GeneratedCode>, ApiError> {
    let project = state.get_project().await
        .ok_or_else(|| ApiError::NotFound("No project loaded".into()))?;
    
    let mut schema = String::from("// Generated by Grapes IDE\n\n");
    schema.push_str("datasource db {\n  provider = \"sqlite\"\n  url      = \"env(\"DATABASE_URL\")\"\n}\n\n");
    schema.push_str("generator client {\n  provider = \"prisma-client-js\"\n}\n\n");
    
    for model in project.data_models.iter().filter(|m| !m.archived) {
        schema.push_str(&format!("model {} {{\n", model.name));
        
        for field in &model.fields {
            let prisma_type = match field.field_type {
                crate::schema::data_model::FieldType::String => "String",
                crate::schema::data_model::FieldType::Int => "Int",
                crate::schema::data_model::FieldType::Float => "Float",
                crate::schema::data_model::FieldType::Boolean => "Boolean",
                crate::schema::data_model::FieldType::DateTime => "DateTime",
                crate::schema::data_model::FieldType::Json => "Json",
                crate::schema::data_model::FieldType::Uuid => "String",
                crate::schema::data_model::FieldType::Email => "String",
                crate::schema::data_model::FieldType::Url => "String",
                crate::schema::data_model::FieldType::Bytes => "Bytes",
                crate::schema::data_model::FieldType::Text => "String",
            };
            
            let mut line = format!("  {} {}", field.name, prisma_type);
            if !field.required { line.push('?'); }
            if field.primary_key { line.push_str(" @id"); }
            if field.unique { line.push_str(" @unique"); }
            
            if let Some(default) = &field.default_value {
                match default {
                    crate::schema::data_model::DefaultValue::Uuid => line.push_str(" @default(uuid())"),
                    crate::schema::data_model::DefaultValue::Now => line.push_str(" @default(now())"),
                    crate::schema::data_model::DefaultValue::AutoIncrement => line.push_str(" @default(autoincrement())"),
                    crate::schema::data_model::DefaultValue::Static { value } => line.push_str(&format!(" @default({})", value)),
                    _ => {}
                }
            }
            
            schema.push_str(&format!("{}\n", line));
        }
        
        if model.timestamps {
            schema.push_str("  createdAt DateTime @default(now())\n");
            schema.push_str("  updatedAt DateTime @updatedAt\n");
        }
        
        schema.push_str("}\n\n");
    }
    
    Ok(Json(GeneratedCode {
        files: vec![
            GeneratedFile {
                path: "prisma/schema.prisma".into(),
                content: schema,
            },
        ],
    }))
}

/// Convert string to PascalCase
fn pascal_case(s: &str) -> String {
    s.split(|c: char| !c.is_alphanumeric())
        .filter(|w| !w.is_empty())
        .map(|w| {
            let mut chars = w.chars();
            match chars.next() {
                None => String::new(),
                Some(c) => c.to_uppercase().chain(chars).collect(),
            }
        })
        .collect()
}

/// Generate ZIP archive of the entire project
pub async fn generate_zip(
    State(state): State<AppState>,
) -> Result<impl axum::response::IntoResponse, ApiError> {
    let project = state.get_project().await
        .ok_or_else(|| ApiError::NotFound("No project loaded".into()))?;

    let mut buf = Vec::new();
    let mut zip = zip::ZipWriter::new(std::io::Cursor::new(&mut buf));
    let options = zip::write::FileOptions::default()
        .compression_method(zip::CompressionMethod::Stored)
        .unix_permissions(0o755);

    // --- FRONTEND ---
    let fe_generator = crate::generator::FrontendGenerator::new(&project);
    let fe_output = fe_generator.generate();
    for file in fe_output.files {
        zip.start_file(format!("client/{}", file.path), options)
            .map_err(|e| ApiError::Internal(e.to_string()))?;
        use std::io::Write;
        zip.write_all(file.content.as_bytes()).map_err(|e| ApiError::Internal(e.to_string()))?;
    }

    // --- BACKEND ---
    let be_generator = crate::generator::BackendGenerator::new(&project);
    let be_output = be_generator.generate();
    for file in be_output.files {
        zip.start_file(format!("server/{}", file.path), options)
            .map_err(|e| ApiError::Internal(e.to_string()))?;
        use std::io::Write;
        zip.write_all(file.content.as_bytes()).map_err(|e| ApiError::Internal(e.to_string()))?;
    }

    // --- DATABASE ---
    let db_generator = crate::generator::DatabaseGenerator::new(&project);
    let db_output = db_generator.generate();
    for file in db_output.files {
        zip.start_file(file.path, options)
            .map_err(|e| ApiError::Internal(e.to_string()))?;
        use std::io::Write;
        zip.write_all(file.content.as_bytes()).map_err(|e| ApiError::Internal(e.to_string()))?;
    }

    // --- CONFIG ---
    zip.start_file("grapes.config.json", options)
        .map_err(|e| ApiError::Internal(e.to_string()))?;
    use std::io::Write;
    let config_json = serde_json::to_string_pretty(&project).unwrap();
    zip.write_all(config_json.as_bytes()).map_err(|e| ApiError::Internal(e.to_string()))?;

    zip.finish().map_err(|e| ApiError::Internal(e.to_string()))?;
    drop(zip);

    Ok((
        axum::http::StatusCode::OK,
        [
            (axum::http::header::CONTENT_TYPE, "application/zip"),
            (axum::http::header::CONTENT_DISPOSITION, "attachment; filename=\"project.zip\""),
        ],
        buf,
    ))
}
