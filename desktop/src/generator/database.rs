//! Database Code Generator
//! 
//! Generates Prisma schema and SQL migrations from data models.

use crate::schema::{ProjectSchema, DataModelSchema};
use crate::schema::data_model::{FieldType, RelationType};

/// Database code generator
pub struct DatabaseGenerator<'a> {
    project: &'a ProjectSchema,
}

impl<'a> DatabaseGenerator<'a> {
    /// Create a new database generator
    pub fn new(project: &'a ProjectSchema) -> Self {
        Self { project }
    }
    
    /// Generate all database code
    pub fn generate(&self) -> GeneratedDatabase {
        let mut files = Vec::new();
        
        // Generate Prisma schema
        files.push(GeneratedFile {
            path: "prisma/schema.prisma".into(),
            content: self.generate_prisma_schema(),
        });
        
        GeneratedDatabase { files }
    }
    
    /// Generate Prisma schema file
    fn generate_prisma_schema(&self) -> String {
        let mut models = String::new();
        
        for model in &self.project.data_models {
            if !model.archived {
                models.push_str(&self.generate_prisma_model(model));
                models.push('\n');
            }
        }
        
        format!(r#"// Prisma schema generated by Akasha
// Learn more: https://pris.ly/d/prisma-schema

generator client {{
    provider = "prisma-client-js"
}}

datasource db {{
    provider = "postgresql"
    url      = env("DATABASE_URL")
}}

{models}"#, models = models)
    }
    
    /// Generate a Prisma model definition
    fn generate_prisma_model(&self, model: &DataModelSchema) -> String {
        let mut fields = String::new();
        
        for field in &model.fields {
            let prisma_type = match field.field_type {
                FieldType::String => "String",
                FieldType::Int => "Int",
                FieldType::Float => "Float",
                FieldType::Boolean => "Boolean",
                FieldType::DateTime => "DateTime",
                FieldType::Json => "Json",
                FieldType::Uuid => "String",
                FieldType::Email => "String",
                FieldType::Url => "String",
                FieldType::Bytes => "Bytes",
                FieldType::Text => "String",
            };
            
            let optional = if field.required { "" } else { "?" };
            let unique = if field.unique { " @unique" } else { "" };
            let pk = if field.primary_key { " @id" } else { "" };
            
            let default_attr = match &field.default_value {
                Some(crate::schema::data_model::DefaultValue::Uuid) => " @default(uuid())",
                Some(crate::schema::data_model::DefaultValue::Now) => " @default(now())",
                Some(crate::schema::data_model::DefaultValue::AutoIncrement) => " @default(autoincrement())",
                Some(crate::schema::data_model::DefaultValue::Static { value }) => {
                    // Handle static defaults based on type
                    if field.field_type == FieldType::String {
                        &format!(" @default(\"{}\")", value)
                    } else {
                        &format!(" @default({})", value)
                    }
                }
                _ => "",
            };
            
            fields.push_str(&format!(
                "    {name:<20} {type}{optional}{pk}{unique}{default}\n",
                name = field.name,
                type = prisma_type,
                optional = optional,
                pk = pk,
                unique = unique,
                default = default_attr
            ));
        }
        
        // Add timestamps if enabled
        if model.timestamps {
            fields.push_str("    createdAt            DateTime @default(now())\n");
            fields.push_str("    updatedAt            DateTime @updatedAt\n");
        }
        
        // Add soft delete if enabled
        if model.soft_delete {
            fields.push_str("    deletedAt            DateTime?\n");
        }
        
        // Add relations
        for relation in &model.relations {
            if let Some(target) = self.project.find_model(&relation.target_model_id) {
                let relation_field = match relation.relation_type {
                    RelationType::OneToOne | RelationType::ManyToOne => {
                        format!("    {:<20} {}?\n", relation.name, target.name)
                    }
                    RelationType::OneToMany | RelationType::ManyToMany => {
                        format!("    {:<20} {}[]\n", relation.name, target.name)
                    }
                };
                fields.push_str(&relation_field);
            }
        }
        
        format!("model {} {{\n{}}}\n", model.name, fields)
    }
}

/// Generated database output
pub struct GeneratedDatabase {
    pub files: Vec<GeneratedFile>,
}

/// A generated file
pub struct GeneratedFile {
    pub path: String,
    pub content: String,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::schema::data_model::{FieldSchema, FieldType};

    #[test]
    fn test_generate_prisma_schema() {
        let mut project = ProjectSchema::new("proj-1", "My App");
        
        let model = DataModelSchema::new("model-1", "User")
            .with_field(FieldSchema::new("f1", "email", FieldType::Email).unique())
            .with_field(FieldSchema::new("f2", "name", FieldType::String));
        
        project.add_data_model(model);
        
        let generator = DatabaseGenerator::new(&project);
        let output = generator.generate();
        
        let schema = &output.files[0].content;
        assert!(schema.contains("model User"));
        assert!(schema.contains("email"));
        assert!(schema.contains("@unique"));
    }
}
